import { z } from "zod";
import type { Option } from "effect";
import type { Action } from "@cuttlekit/common/client";
import type { SandboxContext } from "../sandbox/manager.js";
import type { ComponentSpec } from "../vdom/vdom.js";

// ============================================================
// Zod Schemas
// ============================================================

export const PatchSchema = z.union([
  z.object({ selector: z.string(), text: z.string() }),
  z.object({
    selector: z.string(),
    attr: z.record(z.string(), z.string().nullable()),
  }),
  z.object({ selector: z.string(), append: z.string() }),
  z.object({ selector: z.string(), prepend: z.string() }),
  z.object({ selector: z.string(), html: z.string() }),
  z.object({ selector: z.string(), remove: z.literal(true) }),
]);

export const PatchArraySchema = z.array(PatchSchema);

// Schema for define ops (component registration)
export const DefineOpSchema = z.object({
  op: z.literal("define"),
  tag: z.string(),
  props: z.array(z.string()),
  template: z.string(),
});

// Schema for LLM responses â€” discriminated on `op`
export const LLMResponseSchema = z.union([
  z.object({
    op: z.literal("patches"),
    patches: PatchArraySchema,
  }),
  z.object({
    op: z.literal("full"),
    html: z.string(),
  }),
  DefineOpSchema,
]);

// Full response schema includes stats (generated by code, not LLM)
export const UnifiedResponseSchema = z.union([
  LLMResponseSchema,
  z.object({
    op: z.literal("stats"),
    cacheRate: z.number(),
    tokensPerSecond: z.number(),
    mode: z.enum(["patches", "full"]),
    patchCount: z.number(),
    ttft: z.number(),
    ttc: z.number(),
  }),
]);

// ============================================================
// Exported Types
// ============================================================

export type UnifiedResponse = z.infer<typeof UnifiedResponseSchema>;

export type UnifiedGenerateOptions = {
  sessionId: string;
  currentHtml: Option.Option<string>;
  promptHtml?: Option.Option<string>;
  catalog: Option.Option<string>;
  actions: readonly Action[];
  modelId?: string;
  sandboxCtx?: SandboxContext;
  registrySpecs?: readonly ComponentSpec[];
};

// ============================================================
// Retry Types - Immutable state for functional retry loop
// ============================================================

export type Message = {
  readonly role: "system" | "user" | "assistant";
  readonly content: string;
};


// Usage types for token aggregation
export type Usage = {
  inputTokens?: number;
  outputTokens?: number;
  totalTokens?: number;
  inputTokenDetails?: { cacheReadTokens?: number };
};

export type AggregatedUsage = {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  cachedTokens: number;
};
